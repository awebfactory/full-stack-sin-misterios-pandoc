# Introducción {#intro-00}

Nuevo inicio:

Entre todos los cursos que encontramos en el internet a la hora de adquirir conocimientos prácticos en el desarrollo de soluciones y productos de software, por un lado, y la capacidad de crear una solución o producto uno mismo después de haber seguido un curso de aprendizaje, hay simplemente un abismo.

Este abismo se expresa como una sensación de impotencia total, de sentir "no sé por dónde empezar". Se trata de mirar a un editor de texto vacio, a una carpeta vacia, con una sola pregunta en la cabeza: ¿Por dónde empezar?

Las puentes que nos permiten cruzar ese abismo existen, pero están escondidas y obstruidas por capas de misterio.

Nosotros ofrecemos una solución.

We stand the problem on its head: en vez de seguir un camino de largo estudio, y luego el abordaje de un proyecto, abrazamos el método de "primero el proyecto" (project first). Así partimos del entorno completo que necesitamos para trabajar, y aprendimos lo que necesitamos a medida que avanzamos con el proyecto mismo, en pequeños pasos.

Durante la misma construcción del proyecto, haremos uso de la sección [Recursos]() para conseguir los conocimientos y las herramientas necesarios.

Incluiremos los links necesarios para la sección Recursos en la presentación de los pasos a seguir del proyecto mismo, con un link para retornar al proyecto y seguir trabajando con los conocimientos necesarios.

Luego de completar el proyecto, repasaremos la sección Recursos para rellenar nuestra preparación para el próximo proyecto (y libro en esta serie ... -> link).

(aside) [Ir directamente al proyecto](' ')


Los autores de esta serie de libros ("X" sin misterios) lo escribimos para presentar abiertamente caminos, senderos y pasos a seguir desprovisto del misterio y "partes faltantes" que demasiadas veces son escollos inseparables del proceso de aprendizaje.

Hemos experimentado en carne propia la desorientación, la desesperación y el dolor que, inecesariamente, acompaña el proces de adquisición del conocimiento práctico de lenguajes de programación, entornos de desarrollo y frameworks para aplicaciones web.

Mientras los grandes comparten con ganas todo lo que pueden en forma de tutoriales, código de ejemplo y esqueletos de código (**starter kits**) para hacer aplicaciones web completas, muchas veces es difícil ver el camino.

En el caso de Full Stack JavaScript, las encrucijadas solitarias abundan porque las grandes companías que motorizan la utilización de este o aquel framework, lenguaje, o entorno, están como desesperados ellos mismos para agregarles la funcionalidad y la potencia necesaria para soportar sus nuevos modelos de negocio en el internet.

El resultado de tratar de adquirir conocimientos prácticos de un objetivo en movimiento ("moving target") con alternativas y decisiones que abundan en el camino (React o Angular, Flux o Redux, webpack o browserify, linux o mac, docker o vm o vps, NodeJS o Go para Back End, MySql o MongoDB o CouchDB, Foundation o Bootstrap en el Front End (o Material?) es lo que construye el misterio que queremos quitar. La lista aparenta no tener fin, y se ahonda en detalles con cada nuevo nivel de aprendizaje conquistado.

Y en español este misterio no hace otra cosa que multiplicarse ya que hay menos material disponible que está al tanto de los cambios galopantes y que están dispuestos a contar las cosas como son realmente. Esto se ve aquí y ahora en la cantidad de citas de trabajos escritos en inglés que no tenemos alternativa de hacer para explicar nuestro propósito.

## Vamos por partes y paso a paso

Para entender qué es la adquisición sin misterios de conocimientos prácticos de desarrollo web, y para completar la visión de cómo es y de cómo usar este libro (y la serie de libros que lo acompañará dentro de poco), vamos a ver bien cómo es el misterio que rodea el aprendizaje del desarollo web, y cómo proponemos para quitarlo.

En febrero de 2009, el argentino [Guillermo Rauch](https://github.com/rauchg), autor de [Smashing Node.js](http://www.wiley.com/WileyCDA/WileyTitle/productCd-1119962595.html), escribe un artículo importante: [The four stages of programming competence (Las cuatro etapas de la competencia en lenguajes de programación)](http://www.devthought.com/2009/02/24/the-four-stages-of-programming-competence/), que describe el proceso de adquisición de conocimientos prácticos de la programación en base del esquema de la llamada psicología moderna (En realidad las [Cuatro Etapas de la Competencia](https://en.wikipedia.org/wiki/Four_stages_of_competence#cite_note-Learning_a_New_Skill_is_Easier_Said_than_Done-1) en base al trabajo de  Noel Burch de [Gordon Training International](https://en.wikipedia.org/wiki/Thomas_Gordon_(psychologist)) en los años '70).

¿Cuáles son estas etapas?

...
...
...
...

Luego en mayo de 2015, [Daniel Blumenthal](https://dandreamsofcoding.com/) escribe (sobre la programación (coding)) [Las siete etapas del aprendizaje](https://dandreamsofcoding.com/2015/05/26/seven-stages-of-learning/).

Las etapas que [Dan](https://dandreamsofcoding.com/author/bratfarrar/) enumera son:

* Incompetencia inconciente
* Incompetencia conciente
* Competencia conciente
* Competencia inconciente

### Incompetencia inconciente

Es la etapa del alegre "cortar y pegar" de código ajeno que uno encuentra en [Stack Overflow](http://stackoverflow.com/) o en libros para poder producir programas o soluciones relativamente sencillos, y autoconvencernos (y a otros) que somos programadores. En su versión plena, el individuo cree que no hace falta nada más, es inconciente respecto a lo que podría aprender, piensa que no es necesario aprender nada. Hasta que lo es.

### Incompetencia conciente

Es la etapa de darse cuenta de que, para lograr algún objetivo importante, a uno le falta. De darse cuenta de la necesidad de adquirir expertis en un campo que no es de uno, para poder superar los bloqueos que surgen.

### Competencia conciente

### Competencia inconciente

## Cómo usar este libro

Al seguir los capítulos en orden, van a experimentar un cierto ritmo que es el fruto de nuestra experiencia y estudio de la experiencia de otros en el trabajo y en el apendizaje:

* Bajar, instalar y ver aplicaciones de ejemplo corriendo. Ejecutar código que funciona.
* Ver cómo funciona.
* Adquirir los conocimientos de por qué funciona de esa manera y por qué está construido de tal manera.
* Usar el modelo para hacer algo propio.
* Ver proyectos idearse y tomar forma en base de mejores prácticas.
* Hacer proyectos propios.

## Capítulos y apéndices

...
...
...

## Código de ejemplo

## Otros recursos

## En el primer capítulo, ..., vamos a ...
